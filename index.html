<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collaborative Habit Tracker</title>
    
    <!-- Load Tailwind CSS --><script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Load Firebase Modules (Auth and Firestore) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, query, writeBatch, deleteDoc, getDocs, getDoc, updateDoc, deleteField } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // IMPORTANT: We use window scope for global access in the main script block
        window.firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        window.appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        window.initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // --- RESILIENT INITIALIZATION ---
        try {
            if (window.firebaseConfig.projectId && window.firebaseConfig.apiKey) {
                window.app = initializeApp(window.firebaseConfig);
                window.db = getFirestore(window.app);
                window.auth = getAuth(window.app);
                
                // Exporting key Firestore functions globally for use in the main script block
                window.firestore = {
                    getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, doc, setDoc, onSnapshot, collection, query, writeBatch, deleteDoc, getDocs, getDoc, updateDoc, deleteField
                };
            } else {
                // If config is missing (as on GitHub Pages), prevent app crash
                console.warn("FIREBASE CONFIGURATION MISSING (Expected on GitHub Pages). App will run in Offline/Display Mode.");
                window.app = null;
                window.db = null;
                window.auth = null;
                window.firestore = null; 
            }
        } catch (e) {
            console.error("Firebase initialization failed:", e);
            window.app = null;
            window.db = null;
            window.auth = null;
            window.firestore = null; 
        }
    </script>

    <!-- Load Inter font --><link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    
    <style>
        /* [EXISTING STYLES] */
        body { font-family: 'Inter', sans-serif; background-color: #000000; color: #e5e7eb; }
        .panel { background-color: #111111; border: 1px solid #262626; border-radius: 1rem; padding: 1.5rem; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1); }
        .calendar-container { display: grid; grid-template-columns: repeat(7, minmax(0, 1fr)); gap: 0.5rem; justify-items: center; align-items: center; }
        .calendar-content { display: flex; align-items: center; justify-content: center; padding: 0.375rem 0.75rem; font-weight: 500; transition: all 0.2s ease-in-out; border-radius: 9999px; min-width: 2.5rem; text-align: center; }
        .current-month { color: #d1d5db; cursor: pointer; }
        .current-month .calendar-content:hover { background-color: #262626; color: #ffffff; }
        .other-month { color: #404040; cursor: default; }
        .other-month .calendar-content { pointer-events: none; }
        .today .calendar-content { background-color: #2563eb; color: #ffffff; font-weight: 700; border-radius: 9999px; }
        .today .calendar-content:hover { background-color: #1d4ed8; }
        .selected .calendar-content { background-color: #f59e0b; color: #111111; font-weight: 700; border-radius: 9999px; }
        .selected .calendar-content:hover { background-color: #d97706; }
        .today.selected .calendar-content { background-color: #2563eb; box-shadow: 0 0 0 2px #f59e0b; color: #ffffff; border-radius: 9999px; }
        .stat-bar-bg { background-color: #262626; border-radius: 9999px; height: 0.5rem; overflow: hidden; }
        .stat-bar-fill { height: 100%; transition: width 0.3s ease-in-out; }
        .habit-item { display: flex; align-items: center; justify-content: space-between; padding: 0.75rem; border-radius: 0.5rem; background-color: #1a1a1a; border: 1px solid #333333; transition: all 0.2s ease-in-out; }
        .habit-item.clickable { cursor: pointer; }
        .habit-item:hover { background-color: #262626; }
        .habit-checkbox { height: 1.5rem; width: 1.5rem; flex-shrink-0: 0; cursor: pointer; border-radius: 0.375rem; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 1rem; border: 2px solid #525252; background-color: #404040; transition: all 0.2s ease-in-out; line-height: 1; }
        .habit-checkbox[data-state="0"] { color: transparent; background-color: #404040; border-color: #525252; }
        .habit-checkbox[data-state="1"] { background-color: #16a34a; border-color: #15803d; color: #ffffff; }
        .habit-checkbox[data-state="2"] { background-color: #dc2626; border-color: #b91c1c; color: #ffffff; }
        .styled-input { font-size: 0.875rem; border-radius: 0.375rem; box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); transition: all 0.2s ease-in-out; background-color: #262626; border: 1px solid #525252; color: #e5e7eb; padding: 0.5rem 0.75rem; }
        .styled-input:focus { outline: none; border-color: #f59e0b; box-shadow: 0 0 0 1px #f59e0b; }
        .hour-input, .cup-input { width: 5rem; text-align: center; }
        .remark-input { width: 100%; }
        input[type=number]::-webkit-outer-spin-button, input[type=number]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        input[type=number] { -moz-appearance: textfield; }
        .score-tooltip-container { display: inline-block; cursor: default; margin-left: 1rem; position: relative; }
        .score-tooltip { visibility: hidden; background-color: #262626; color: #e5e7eb; text-align: left; border-radius: 0.5rem; padding: 0.75rem 1rem; position: absolute; z-index: 10; top: 120%; left: 50%; transform: translateX(-50%); white-space: nowrap; opacity: 0; transition: opacity 0.3s, visibility 0.3s, transform 0.3s; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5); border: 1px solid #404040; }
        .score-tooltip-container:hover .score-tooltip { visibility: visible; opacity: 1; top: 120%; transform: translateX(-50%); }
        .tooltip-row { display: flex; justify-content: space-between; align-items: center; font-size: 0.875rem; }
        .tooltip-row span:first-child { color: #a3a3a3; margin-right: 1rem; }
        .tooltip-row span:last-child { font-weight: 700; }
        
        /* New Styles for Dynamic Habits UI */
        .loading-overlay { @apply absolute inset-0 flex items-center justify-center bg-gray-900 bg-opacity-70 z-20 rounded-xl; }
        
        .challenge-btn {
            @apply flex items-center justify-center py-2 px-3 rounded-lg font-semibold transition-colors w-full;
        }
        .challenge-btn.solo {
            @apply bg-orange-600 text-white hover:bg-orange-500;
        }
        .challenge-btn.group {
            @apply bg-green-600 text-white hover:bg-green-500;
        }
        /* Modal Styles */
        .modal {
            @apply fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-75 transition-opacity duration-300;
        }
        .modal-content {
            @apply bg-neutral-900 p-6 rounded-xl shadow-2xl w-full max-w-md border border-neutral-700;
        }

        /* Style for Group Member Display */
        .member-progress-item {
            @apply flex items-center justify-between text-sm py-1 border-b border-neutral-800 last:border-b-0;
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <!-- Challenge Modal (Hidden by default) -->
    <div id="challenge-modal" class="modal hidden">
        <div class="modal-content">
            <h3 id="modal-title" class="text-xl font-bold text-white mb-4">Start New Challenge</h3>
            
            <div class="space-y-4">
                
                <!-- Habit Selection -->
                <div>
                    <label class="block text-sm font-medium text-neutral-400 mb-1">Select Habit to Track</label>
                    <select id="challenge-habit-select" class="styled-input w-full"></select>
                </div>

                <!-- Goal Target -->
                <div>
                    <label class="block text-sm font-medium text-neutral-400 mb-1">Total Target Goal</label>
                    <div class="flex space-x-2">
                        <input id="challenge-target-input" type="number" step="1" min="1" value="1" class="styled-input w-24 text-center">
                        <span id="challenge-unit-display" class="text-neutral-300 flex items-center">times (checkbox)</span>
                    </div>
                </div>

                <!-- Duration -->
                <div>
                    <label class="block text-sm font-medium text-neutral-400 mb-1">Duration</label>
                    <select id="challenge-duration-select" class="styled-input w-full">
                        <option value="1">1 Week</option>
                        <option value="2">2 Weeks</option>
                        <option value="3">3 Weeks</option>
                        <option value="4">4 Weeks</option>
                    </select>
                </div>

            </div>

            <!-- Modal Action Buttons -->
            <div class="mt-6 flex justify-end space-x-3">
                <button id="modal-cancel-btn" class="bg-neutral-600 text-white px-4 py-2 rounded-lg font-bold hover:bg-neutral-500 transition-colors">
                    Cancel
                </button>
                <button id="modal-start-btn" class="bg-amber-500 text-black px-4 py-2 rounded-lg font-bold hover:bg-amber-400 transition-colors">
                    Start Challenge
                </button>
            </div>

            <p id="modal-error-message" class="text-red-400 text-sm mt-3 text-center min-h-[1.5rem]"></p>
        </div>
    </div>
    <!-- End Challenge Modal -->

    <!-- Main Grid Container -->
    <div class="grid grid-cols-1 lg:grid-cols-4 gap-6 max-w-7xl mx-auto">

        <!-- Header (Spans all columns) -->
        <header class="panel lg:col-span-4 flex items-center justify-between relative"> 
            <div class="flex flex-col">
                <div class="flex items-center">
                    <h1 id="main-title" class="text-3xl font-extrabold text-white">Daily Tracker</h1>
                    
                    <!-- Score Icon and Tooltip Container --><div class="score-tooltip-container">
                        <div class="w-10 h-10 rounded-full flex items-center justify-center cursor-default">
                            <!-- Medal Icon SVG --><svg class="w-8 h-8" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" fill="#f59e0b" opacity="0.3"/>
                                <path d="M12 11.5c-1.38 0-2.5 1.12-2.5 2.5s1.12 2.5 2.5 2.5 2.5-1.12 2.5-2.5-1.12-2.5-2.5-2.5z" fill="#f59e0b"/>
                                <path d="M12 7c-1.38 0-2.5 1.12-2.5 2.5v.5h5v-.5c0-1.38-1.12-2.5-2.5-2.5z" fill="#f59e0b"/>
                                <path d="M14.5 14c0 1.38-1.12 2.5-2.5 2.5s-2.5-1.12-2.5-2.5 1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5z" fill="#f59e0b"/>
                                <path d="M18.88 15.63l-1.41-1.41c-.46-.46-1.13-.72-1.85-.72H8.38c-.72 0-1.39.26-1.85.72l-1.41 1.41c-.46.46-.72 1.13-.72 1.85V19h15v-1.52c0-.72-.26-1.39-.72-1.85z" fill="#f97316"/>
                                <path d="M12 4.5c-1.38 0-2.5 1.12-2.5 2.5v.5h5v-.5c0-1.38-1.12-2.5-2.5-2.5z" fill="#f97316"/>
                                <path d="M12 9.5c-1.38 0-2.5 1.12-2.5 2.5s1.12 2.5 2.5 2.5 2.5-1.12 2.5-2.5-1.12-2.5-2.5-2.5z" fill="#f97316"/>
                            </svg>
                        </div>
                        
                        <div class="score-tooltip">
                            <div class="tooltip-row border-b border-neutral-700 pb-2 mb-2">
                                <span class="text-white font-bold">SCORE SUMMARY</span>
                                <span class="text-white font-bold">POINTS</span>
                            </div>
                            <div class="tooltip-row text-amber-300">
                                <span>Today's Score</span>
                                <span id="tooltip-today-score">0 / 10</span>
                            </div>
                            <div class="tooltip-row text-amber-500 font-bold">
                                <span>Monthly Total</span>
                                <span id="tooltip-monthly-score">0</span>
                            </div>
                        </div>
                    </div><!-- END Score Icon and Tooltip Container -->
                </div>
                <p class="text-amber-500 font-medium mt-1">All roads lead to Rome.</p>
                <!-- NEW: Display User ID -->
                <p class="text-xs text-neutral-500 mt-2">User ID: <span id="user-id">Loading...</span></p>
            </div>
            
            <img src="https://placehold.co/80x80/111/555?text=Rabbit" 
                alt="Rabbit" 
                class="w-20 h-20 rounded-xl object-cover shadow-lg border-2 border-neutral-700"
                onerror="this.src='https://placehold.co/80x80/111/555?text=Rabbit'; this.onerror=null;">
        </header>

        <!-- Left Sidebar (Stats) --><aside class="lg:col-span-1 flex flex-col gap-6">
            
            <!-- Streaks Panel --><div class="panel text-center">
                <!-- Flame Icon SVG --><svg class="w-16 h-16 text-orange-500 mx-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 18.657A8 8 0 016.343 7.343m11.314 11.314a8 8 0 00-11.314-11.314m11.314 11.314L6.343 7.343m1.414 1.414A6 6 0 0117.657 17.657m-1.414-1.414A6 6 0 007.757 7.757m1.414 1.414a4 4 0 015.657 5.657m-1.414-1.414a4 4 0 00-5.657-5.657m1.414 1.414a2 2 0 012.828 2.828m0 0l-2.828-2.828"></path></svg>
                <h2 id="streak-value" class="text-5xl font-extrabold text-white mt-2">0</h2> 
                <p class="text-neutral-400 font-medium">Day Streak</p>
            </div>
            
            <!-- Group & Collaboration Panel --><div class="panel">
                <h3 class="text-lg font-bold text-white mb-4">Group & Collaboration</h3>
                
                <!-- Group Status -->
                <div class="flex justify-between items-center mb-4 p-2 bg-neutral-900 rounded-lg border border-neutral-700">
                    <div>
                        <span class="text-sm font-medium text-neutral-400">Group Status:</span>
                        <span id="group-status" class="font-bold text-amber-500 ml-1">Solo</span>
                    </div>
                    <div>
                        <span class="text-sm font-medium text-neutral-400">Members:</span>
                        <span id="group-members-count" class="font-bold text-white ml-1">1</span>
                    </div>
                </div>

                <!-- Join/Create Group Form -->
                <div id="group-form">
                    <h4 class="text-sm font-semibold text-neutral-300 mb-2">Manage Group</h4>
                    <div class="flex space-x-2 mb-2">
                        <input id="group-id-input" type="text" class="styled-input flex-grow" placeholder="Enter Group ID">
                        <button id="join-group-btn" class="bg-blue-600 text-white px-4 py-2 rounded-lg font-bold hover:bg-blue-500 transition-colors flex-shrink-0">
                            Join
                        </button>
                    </div>
                    <button id="create-group-btn" class="bg-green-600 text-white px-4 py-2 rounded-lg font-bold hover:bg-green-500 transition-colors w-full">
                        Create New Group
                    </button>
                    <p id="group-message" class="text-xs text-neutral-400 mt-2 min-h-[1.5rem]"></p>
                </div>

                <!-- Challenge Buttons -->
                <div class="mt-4 space-y-2">
                    <button id="solo-challenge-btn" class="challenge-btn solo">
                        Start Solo Challenge
                    </button>
                    <button id="group-challenge-btn" id="group-challenge-btn" class="challenge-btn group" disabled>
                        Start Group Challenge
                    </button>
                </div>
            </div>
            
            <!-- Active Challenge Panel (NEWLY ADDED HTML) -->
            <div id="active-challenge-panel" class="panel hidden">
                <h3 class="text-lg font-bold text-white mb-4 flex justify-between items-center">
                    Active Challenge
                    <button id="challenge-complete-btn" class="text-green-500 text-xs font-semibold hover:text-green-400">
                         Complete & End
                    </button>
                </h3>
                
                <div id="challenge-status-content" class="space-y-3">
                    <p class="text-neutral-300 font-medium" id="challenge-name-display">Loading...</p>

                    <!-- Progress Bar -->
                    <div>
                        <div class="flex justify-between text-sm font-semibold mb-1">
                            <span id="challenge-progress-value" class="text-amber-400">0%</span>
                            <span id="challenge-goal-display" class="text-white">0 / 0</span>
                        </div>
                        <div class="stat-bar-bg">
                            <div id="challenge-progress-bar" class="stat-bar-fill bg-amber-500" style="width: 0%;"></div>
                        </div>
                    </div>
                    
                    <p class="text-xs text-neutral-400" id="challenge-time-remaining">Ends in X weeks.</p>

                    <!-- Group Member Progress List (NEW) -->
                    <div id="group-member-progress" class="pt-3 border-t border-neutral-800">
                        <h4 class="text-xs font-semibold text-neutral-500 mb-2">Participants</h4>
                        <div id="member-list-container">
                            <!-- Member progress bars/names go here -->
                        </div>
                    </div>
                </div>
            </div>
            <!-- END Active Challenge Panel -->
            
            <!-- Daily Average Panel --><div class="panel">
                <h3 class="text-lg font-bold text-white mb-4">Daily Averages</h3>
                <div id="avg-bars-container" class="space-y-4">
                    <!-- Dynamic Bars will go here -->
                </div>
            </div>

            <!-- Monthly Stats Panel --><div class="panel">
                <h3 class="text-lg font-bold text-white mb-4">Monthly Stats</h3>
                <div class="space-y-3">
                    <div class="flex items-center justify-between text-green-500">
                        <span class="font-medium">Completed Habits</span> 
                        <span id="stats-completed" class="font-bold">0</span> 
                    </div>
                    <div class="flex items-center justify-between text-red-500">
                        <span class="font-medium">Failed Habits</span> 
                        <span id="stats-failed" class="font-bold">0</span> 
                    </div>
                    <div class="flex items-center justify-between text-neutral-500">
                        <span class="font-medium">Skipped Habits</span> 
                        <span id="stats-skipped" class="font-bold">0</span> 
                    </div>
                </div>
            </div>

        </aside>

        <!-- Main Content (Calendar) --><main class="panel lg:col-span-2 relative">
            
            <!-- Calendar Header --><div class="flex justify-between items-center mb-4">
                <button id="prev-month-btn" title="Previous Month" class="p-2 rounded-lg hover:bg-neutral-800 transition-colors">
                    <svg class="w-6 h-6 text-neutral-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>
                </button>
                <h2 id="month-year-title" class="text-xl font-bold text-white"></h2>
                <button id="next-month-btn" title="Next Month" class="p-2 rounded-lg hover:bg-neutral-800 transition-colors">
                    <svg class="w-6 h-6 text-neutral-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                </button>
            </div>
            
            <!-- Calendar Day Headers --><div class="calendar-container mb-2 text-center text-xs font-semibold text-neutral-500 uppercase">
                <div class="calendar-content">M</div>
                <div class="calendar-content">T</div>
                <div class="calendar-content">W</div>
                <div class="calendar-content">T</div>
                <div class="calendar-content">F</div>
                <div class="calendar-content">S</div>
                <div class="calendar-content">S</div>
            </div>
            
            <!-- Calendar Grid (to be filled by JS) --><div id="calendar-grid" class="calendar-container">
                <!-- Days will be dynamically inserted here -->
            </div>

        </main>

        <!-- Right Sidebar (Habits) --><aside class="lg:col-span-1 flex flex-col gap-6">
            
            <!-- Custom Habit Management -->
            <div class="panel">
                <h3 class="text-lg font-bold text-white mb-4">Habit Setup</h3>
                <div id="habit-setup-list" class="space-y-2">
                    <!-- Habit Definitions will be listed here -->
                </div>
                <div class="mt-4 flex space-x-2">
                    <input id="new-habit-name" type="text" class="styled-input flex-grow" placeholder="New Habit Name">
                    <select id="new-habit-type" class="styled-input w-24">
                        <option value="checkbox">Check</option>
                        <option value="number-hr">Hours</option>
                        <option value="number-cup">Cups</option>
                    </select>
                    <button id="add-habit-btn" class="bg-amber-500 text-black px-4 py-2 rounded-lg font-bold hover:bg-amber-400 transition-colors flex-shrink-0">
                        Add
                    </button>
                </div>
            </div>

            <!-- Today's Habits Panel -->
            <div class="panel relative">
                <h3 id="habits-title" class="text-lg font-bold text-white mb-4">Today's Habits</h3>
                <div id="habits-list" class="space-y-3">
                    <!-- Habits will be dynamically inserted here -->
                </div>
                
                <!-- Loading Overlay -->
                <div id="loading-overlay" class="loading-overlay" style="display: none;">
                    <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-white"></div>
                </div>
            </div>

        </aside>

    </div>

    <script>
        // --- Global Variables (Defined before execution starts) ---
        
        // These will be accessed via window scope after the module script runs
        let db, auth, appId, initialAuthToken;
        let firestoreFunctions = {};

        // --- Core State Management ---
        const HABIT_DEFINITIONS_DOC_ID = 'userHabits';
        const HABIT_DEFINITIONS_COLLECTION = 'habitDefinitions'; 
        const USER_GROUP_DOC_ID = 'groupMembership';
        const USER_GROUP_COLLECTION = 'metadata';
        const GROUPS_COLLECTION = 'groups'; 
        const CHALLENGES_COLLECTION = 'challenges'; // New collection for public challenges
        
        const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        
        let today = new Date();
        today.setHours(0, 0, 0, 0); 
        
        let currentMonth = today.getMonth();
        let currentYear = today.getFullYear();
        let selectedDate = new Date(today); 
        
        let habitData = {}; 
        let habitDefinitions = []; 
        let userId = null;
        let isAuthReady = false;

        // Group State
        let groupId = null;
        let groupMembers = {};
        let groupListener = null;

        // Challenge State
        let activeChallenge = null; // {id, type, habitId, target, durationWeeks, participants: {userId: {progress: 0, ...}}}
        let challengeListener = null;


        // --- 2. Element References ---
        const monthYearTitle = document.getElementById('month-year-title');
        const calendarGrid = document.getElementById('calendar-grid');
        const habitsList = document.getElementById('habits-list');
        const habitsTitle = document.getElementById('habits-title');
        const avgBarsContainer = document.getElementById('avg-bars-container');
        const streakValue = document.getElementById('streak-value');
        const userIdSpan = document.getElementById('user-id');
        const loadingOverlay = document.getElementById('loading-overlay');
        const habitSetupList = document.getElementById('habit-setup-list');
        const newHabitNameInput = document.getElementById('new-habit-name');
        const newHabitTypeSelect = document.getElementById('new-habit-type');
        const addHabitBtn = document.getElementById('add-habit-btn');
        
        // --- Group References ---
        const groupStatusSpan = document.getElementById('group-status');
        const groupMembersCountSpan = document.getElementById('group-members-count');
        const groupIdInput = document.getElementById('group-id-input');
        const joinGroupBtn = document.getElementById('join-group-btn');
        const createGroupBtn = document.getElementById('create-group-btn');
        const groupMessage = document.getElementById('group-message');
        const soloChallengeBtn = document.getElementById('solo-challenge-btn');
        const groupChallengeBtn = document.getElementById('group-challenge-btn');
        
        // --- Challenge Display References (NEW) ---
        const activeChallengePanel = document.getElementById('active-challenge-panel');
        const challengeNameDisplay = document.getElementById('challenge-name-display');
        const challengeProgressValue = document.getElementById('challenge-progress-value');
        const challengeGoalDisplay = document.getElementById('challenge-goal-display');
        const challengeProgressBar = document.getElementById('challenge-progress-bar');
        const challengeTimeRemaining = document.getElementById('challenge-time-remaining');
        const challengeCompleteBtn = document.getElementById('challenge-complete-btn'); // Defined here
        const memberListContainer = document.getElementById('member-list-container'); // NEW container reference
        

        // --- Modal References (NEW) ---
        const challengeModal = document.getElementById('challenge-modal');
        const modalTitle = document.getElementById('modal-title');
        const challengeHabitSelect = document.getElementById('challenge-habit-select');
        const challengeTargetInput = document.getElementById('challenge-target-input');
        const challengeUnitDisplay = document.getElementById('challenge-unit-display');
        const challengeDurationSelect = document.getElementById('challenge-duration-select');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');
        const modalStartBtn = document.getElementById('modal-start-btn');
        const modalErrorMessage = document.getElementById('modal-error-message');


        // --- Tooltip references ---
        const tooltipTodayScore = document.getElementById('tooltip-today-score');
        const tooltipMonthlyScore = document.getElementById('tooltip-monthly-score');
        const statsCompleted = document.getElementById('stats-completed');
        const statsFailed = document.getElementById('stats-failed');
        const statsSkipped = document.getElementById('stats-skipped');
        
        
        // --- 3. Helper Functions ---
        function getDateKey(date) {
            const year = date.getFullYear();
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = date.getDate().toString().padStart(2, '0'); 
            return `${year}-${month}-${day}`;
        }
        function getHabitColor(index) {
            const colors = ['#f97316', '#16a34a', '#2563eb', '#7c3aed', '#14b8a6', '#f59e0b', '#dc2626', '#3b82f6'];
            return colors[index % colors.length];
        }
        function generateRandomId() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }
        
        // --- 4. Firestore Path Functions ---

        function getUserDataPath(docId) {
            if (!userId) {
                console.error("User ID is not set.");
                return null;
            }
            return firestoreFunctions.doc(db, 'artifacts', appId, 'users', userId, 'dailyEntries', docId);
        }

        function getHabitDefinitionsPath() {
             if (!userId) {
                console.error("User ID is not set.");
                return null;
            }
            return firestoreFunctions.doc(db, 'artifacts', appId, 'users', userId, HABIT_DEFINITIONS_COLLECTION, HABIT_DEFINITIONS_DOC_ID);
        }

        function getUserGroupMetadataPath() {
             if (!userId) {
                console.error("User ID is not set.");
                return null;
            }
            return firestoreFunctions.doc(db, 'artifacts', appId, 'users', userId, USER_GROUP_COLLECTION, USER_GROUP_DOC_ID);
        }

        function getGroupPath(gId) {
            if (!gId) {
                console.error("Group ID is missing.");
                return null;
            }
            return firestoreFunctions.doc(db, 'artifacts', appId, 'public', 'data', GROUPS_COLLECTION, gId);
        }
        
        function getChallengePath(cId) {
            if (!cId) {
                console.error("Challenge ID is missing.");
                return null;
            }
            return firestoreFunctions.doc(db, 'artifacts', appId, 'public', 'data', CHALLENGES_COLLECTION, cId);
        }

        // --- 5. Group Management Logic ---

        function setupGroupMetadataListener() {
            if (!userId || !firestoreFunctions) return;

            const docRef = getUserGroupMetadataPath();

            firestoreFunctions.onSnapshot(docRef, (docSnap) => {
                const data = docSnap.data();
                const newGroupId = data?.groupId || null;
                const newChallengeId = data?.activeChallengeId || null;
                
                // 1. Handle Group Change
                if (newGroupId !== groupId) {
                    groupId = newGroupId;
                    
                    if (groupListener) groupListener(); 

                    if (groupId) {
                        setupPublicGroupDetailsListener(groupId);
                    } else {
                        groupStatusSpan.textContent = 'Solo';
                        groupStatusSpan.classList.add('text-amber-500');
                        groupStatusSpan.classList.remove('text-green-500');
                        groupMembersCountSpan.textContent = '1';
                        groupChallengeBtn.disabled = true;
                    }
                }
                
                // 2. Handle Challenge Change
                if (newChallengeId !== (activeChallenge ? activeChallenge.id : null)) {
                    if (challengeListener) challengeListener();
                    if (newChallengeId) {
                        setupActiveChallengeListener(newChallengeId);
                    } else {
                        activeChallenge = null;
                        renderActiveChallengeUI(); // Hide panel
                    }
                }
                
                renderGroupUI();
            }, (error) => {
                console.error("Error listening to group metadata:", error);
            });
        }
        
        function setupPublicGroupDetailsListener(gId) {
            const docRef = getGroupPath(gId);
            
            groupListener = firestoreFunctions.onSnapshot(docRef, (docSnap) => {
                if (docSnap.exists() && docSnap.data().members) {
                    groupMembers = docSnap.data().members;
                    const count = Object.keys(groupMembers).length;
                    groupMembersCountSpan.textContent = count.toString();
                } else {
                    leaveGroup(false); 
                }
                renderGroupUI();
            }, (error) => {
                console.error("Error listening to public group details:", error);
            });
        }
        
        async function createGroup() {
            if (!userId || !firestoreFunctions) { groupMessage.textContent = "Database not connected."; return; }
            if (groupId) { groupMessage.textContent = "You must leave your current group first."; return; }

            const newGroupId = generateRandomId();
            const groupDocRef = getGroupPath(newGroupId);

            try {
                await firestoreFunctions.setDoc(groupDocRef, {
                    creatorId: userId,
                    createdAt: new Date().toISOString(),
                    members: { [userId]: true }
                });
                
                await firestoreFunctions.setDoc(getUserGroupMetadataPath(), { groupId: newGroupId }, { merge: true });
                
                groupMessage.textContent = `Group Created! Share this ID: ${newGroupId}`;
                groupIdInput.value = newGroupId;
            } catch (e) {
                console.error("Error creating group:", e);
                groupMessage.textContent = "Failed to create group. Try again.";
            }
        }
        
        async function joinGroup() {
            if (!userId || !firestoreFunctions) { groupMessage.textContent = "Database not connected."; return; }
            if (groupId) { groupMessage.textContent = "You are already in a group. Leave first."; return; }
            const enteredId = groupIdInput.value.trim().toUpperCase();
            if (enteredId.length !== 6) { groupMessage.textContent = "Invalid Group ID format (must be 6 chars)."; return; }

            const groupDocRef = getGroupPath(enteredId);

            try {
                const docSnap = await firestoreFunctions.getDoc(groupDocRef);
                if (!docSnap.exists()) {
                    groupMessage.textContent = `Group ID "${enteredId}" not found.`;
                    return;
                }
                
                await firestoreFunctions.updateDoc(groupDocRef, {
                    [`members.${userId}`]: true
                });

                await firestoreFunctions.setDoc(getUserGroupMetadataPath(), { groupId: enteredId }, { merge: true });
                
                groupMessage.textContent = `Joined group ${enteredId}!`;
            } catch (e) {
                console.error("Error joining group:", e);
                groupMessage.textContent = "Failed to join group. Check the ID and try again.";
            }
        }

        async function leaveGroup(shouldDeleteIfLast = true) {
            if (!userId || !groupId || !firestoreFunctions) return;

            const groupDocRef = getGroupPath(groupId);
            const currentGroupId = groupId;
            
            try {
                await firestoreFunctions.updateDoc(groupDocRef, {
                    [`members.${userId}`]: firestoreFunctions.deleteField()
                });

                const snap = await firestoreFunctions.getDoc(groupDocRef);
                const memberKeys = Object.keys(snap.data()?.members || {}).filter(id => id !== userId); // Filter out current user locally

                if (shouldDeleteIfLast && memberKeys.length === 0) {
                    await firestoreFunctions.deleteDoc(groupDocRef);
                }

                await firestoreFunctions.updateDoc(getUserGroupMetadataPath(), { groupId: firestoreFunctions.deleteField() });
                
                groupMessage.textContent = `Left group ${currentGroupId}.`;
            } catch (e) {
                 if (e.code === 'not-found') {
                     await firestoreFunctions.updateDoc(getUserGroupMetadataPath(), { groupId: firestoreFunctions.deleteField() });
                 } else {
                     console.error("Error leaving group:", e);
                     groupMessage.textContent = "Failed to leave group. Check console for details.";
                 }
            }
        }

        function renderGroupUI() {
            // Check if saving is disabled before enabling buttons
            const isSavingEnabled = !!window.auth;

            if (groupId) {
                groupStatusSpan.textContent = `Group: ${groupId}`;
                groupStatusSpan.classList.add('text-green-500');
                groupStatusSpan.classList.remove('text-amber-500');
                createGroupBtn.textContent = 'Leave Group';
                createGroupBtn.classList.remove('bg-green-600', 'hover:bg-green-500');
                createGroupBtn.classList.add('bg-red-600', 'hover:bg-red-500');
                joinGroupBtn.style.display = 'none';
                groupIdInput.style.display = 'none';
            } else {
                groupStatusSpan.textContent = 'Solo';
                groupStatusSpan.classList.add('text-amber-500');
                groupStatusSpan.classList.remove('text-green-500');
                groupMembersCountSpan.textContent = '1';
                createGroupBtn.textContent = 'Create New Group';
                createGroupBtn.classList.add('bg-green-600', 'hover:bg-green-500');
                createGroupBtn.classList.remove('bg-red-600', 'hover:bg-red-500');
                joinGroupBtn.style.display = 'block';
                groupIdInput.style.display = 'block';
            }
            
            // Disable buttons if we are offline (no window.auth)
            createGroupBtn.disabled = !isSavingEnabled;
            joinGroupBtn.disabled = !isSavingEnabled;
            groupChallengeBtn.disabled = !groupId || !isSavingEnabled;

            if (!isSavingEnabled) {
                if (groupMessage.textContent === '') {
                    groupMessage.textContent = 'Database required for Group features.';
                }
                createGroupBtn.classList.remove('bg-green-600', 'bg-red-600', 'hover:bg-green-500', 'hover:bg-red-500');
                createGroupBtn.classList.add('bg-neutral-600');
                joinGroupBtn.classList.remove('bg-blue-600', 'hover:bg-blue-500');
                joinGroupBtn.classList.add('bg-neutral-600');
            } else {
                 if (groupMessage.textContent === 'Database required for Group features.') {
                     groupMessage.textContent = '';
                 }
            }
        }

        // --- 5. Challenge Management Logic ---

        /**
         * Listens to the active challenge document.
         */
        function setupActiveChallengeListener(challengeId) {
             if (!userId || !firestoreFunctions) return;

             const docRef = getChallengePath(challengeId);
             
             challengeListener = firestoreFunctions.onSnapshot(docRef, (docSnap) => {
                 if (docSnap.exists()) {
                     activeChallenge = docSnap.data();
                     // Recalculate progress based on current habit data
                     updateChallengeProgress(activeChallenge);
                 } else {
                     // Challenge was deleted/ended by creator
                     endChallengeLocally();
                 }
                 renderActiveChallengeUI();
             }, (error) => {
                 console.error("Error listening to active challenge:", error);
                 endChallengeLocally();
             });
        }
        
        /**
         * Calculates and updates the user's progress for the challenge.
         */
        async function updateChallengeProgress(challenge) {
            if (!userId || !challenge || !firestoreFunctions) return;

            let currentProgress = 0;
            
            // Iterate over daily entries within the challenge date range
            for (const dateKey in habitData) {
                if (dateKey >= challenge.startDate && dateKey <= challenge.endDate) {
                    const dailyEntry = habitData[dateKey];
                    if (dailyEntry && dailyEntry[challenge.habitId] !== undefined) {
                        const value = dailyEntry[challenge.habitId];
                        
                        if (challenge.unit === 'count') {
                            // Checkbox habit: 1 point per day completed (state 1)
                            if (value === 1) {
                                currentProgress += 1;
                            }
                        } else {
                            // Number habit: Accumulate the numerical value
                            currentProgress += parseFloat(value) || 0;
                        }
                    }
                }
            }

            // Update progress in Firestore if needed
            if (challenge.participants[userId] && challenge.participants[userId].progress !== currentProgress) {
                 const docRef = getChallengePath(challenge.id);
                 await firestoreFunctions.updateDoc(docRef, {
                     [`participants.${userId}.progress`]: currentProgress,
                     [`participants.${userId}.lastUpdated`]: new Date().toISOString()
                 });
            }
        }

        function endChallengeLocally() {
            activeChallenge = null;
            if (challengeListener) challengeListener();
            
            if (window.auth) {
                // Database is connected, update metadata
                firestoreFunctions.updateDoc(getUserGroupMetadataPath(), { activeChallengeId: firestoreFunctions.deleteField() });
            } else {
                 // Offline mode, just clear session storage
                 sessionStorage.removeItem('activeChallenge');
            }

            renderActiveChallengeUI();
        }

        function renderActiveChallengeUI() {
            const activeChallengePanel = document.getElementById('active-challenge-panel');
            
            if (!activeChallenge) {
                activeChallengePanel.classList.add('hidden');
                // --- OFFLINE FIX: Ensure Active Challenge data is always checked from storage here ---
                const storedChallenge = sessionStorage.getItem('activeChallenge');
                if (storedChallenge) {
                     try {
                          activeChallenge = JSON.parse(storedChallenge);
                     } catch(e) {
                          console.error("Failed to parse stored challenge:", e);
                     }
                }
                if (!activeChallenge) return; // If still null, return
            }

            // --- Continue Rendering UI ---
            activeChallengePanel.classList.remove('hidden');
            const userProgress = activeChallenge.participants[userId || 'default']?.progress || 0; // Use 'default' placeholder if offline
            const goal = activeChallenge.target;
            const percentage = Math.min(100, (userProgress / goal) * 100);
            const unit = activeChallenge.unit;
            
            challengeNameDisplay.textContent = activeChallenge.name;
            challengeGoalDisplay.textContent = `${userProgress.toFixed(unit === 'hrs' ? 1 : 0)} / ${goal} ${unit}`;
            challengeProgressValue.textContent = `${percentage.toFixed(0)}%`;
            challengeProgressBar.style.width = `${percentage}%`;
            
            // Calculate time remaining
            const endDate = new Date(activeChallenge.endDate + 'T23:59:59'); 
            const diffTime = endDate.getTime() - today.getTime();
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            
            if (diffDays <= 0) {
                 challengeTimeRemaining.textContent = "Challenge ended.";
                 if (diffDays <= 0 || userProgress >= goal) {
                     challengeCompleteBtn.textContent = 'Challenge Ended (View Result)';
                     challengeCompleteBtn.onclick = endChallengeLocally;
                 }
            } else if (diffDays <= 7) {
                 challengeTimeRemaining.textContent = `Ends in ${diffDays} day${diffDays === 1 ? '' : 's'}.`;
            } else {
                 const diffWeeks = Math.ceil(diffDays / 7);
                 challengeTimeRemaining.textContent = `Ends in ${diffWeeks} week${diffWeeks === 1 ? '' : 's'}.`;
            }
            
            challengeCompleteBtn.textContent = userProgress >= goal ? 'Goal Achieved!' : 'End Challenge';
            challengeCompleteBtn.disabled = userProgress < goal;
            
            if (userProgress >= goal) {
                 challengeCompleteBtn.textContent = 'Goal Achieved! (Click to End)';
                 challengeCompleteBtn.classList.remove('bg-red-600');
                 challengeCompleteBtn.classList.add('bg-green-600');
            } else {
                 challengeCompleteBtn.classList.add('bg-red-600');
                 challengeCompleteBtn.classList.remove('bg-green-600');
            }

            // --- Group Member Progress Display ---
            const challengeGoal = activeChallenge.target;
            
            if (activeChallenge.type === 'group') {
                const membersHtml = Object.entries(activeChallenge.participants).map(([memberId, participant]) => {
                    const memberProgress = participant.progress || 0;
                    const isCurrentUser = memberId === (userId || 'default');
                    const color = isCurrentUser ? 'text-amber-500' : 'text-neutral-300';
                    const name = isCurrentUser ? 'You' : memberId.substring(0, 8);

                    return `
                        <div class="member-progress-item">
                            <span class="${color} font-medium">${name}</span>
                            <span class="${color} font-bold">${memberProgress.toFixed(unit === 'hrs' ? 1 : 0)} / ${challengeGoal}</span>
                        </div>
                    `;
                }).join('');
                memberListContainer.innerHTML = membersHtml;
            } else {
                memberListContainer.innerHTML = `<p class="text-xs text-neutral-500">This is a solo challenge. Check your progress above!</p>`;
            }
            
            // --- OFFLINE FIX: Update progress locally for display ---
            if (!window.auth) {
                 sessionStorage.setItem('activeChallenge', JSON.stringify(activeChallenge));
            }
        }
        
        // --- Modal Logic ---

        function openChallengeModal(type) {
            if (!userId && window.auth) { alert("Please wait for authentication."); return; }
            if (habitDefinitions.length === 0) { alert("Please add at least one habit first!"); return; }
            if (activeChallenge) { alert("Please complete or end your current challenge before starting a new one."); return; }
            if (type === 'group' && !groupId) { alert("You must create or join a group to start a group challenge."); return; }

            // Disable group challenge option if offline, force mock solo
            if (type === 'group' && !window.auth) {
                 alert("Group challenges are disabled in Offline Mode. Starting Solo challenge mock.");
                 type = 'solo';
            }
            
            modalTitle.textContent = `${type === 'solo' ? 'Start Solo Challenge' : 'Start Group Challenge'}`;
            challengeModal.dataset.type = type;
            modalErrorMessage.textContent = '';
            
            // Populate habit dropdown
            challengeHabitSelect.innerHTML = habitDefinitions.map(h => {
                const name = h.name.replace(/\s\(.*\)/g, '').trim();
                return `<option value="${h.id}">${name} (${h.type.split('-')[0]})</option>`;
            }).join('');

            // Set default values and update unit display
            challengeDurationSelect.value = '1';
            challengeTargetInput.value = 7;
            updateChallengeUnitDisplay();
            
            challengeModal.classList.remove('hidden');
        }

        function closeChallengeModal() {
            challengeModal.classList.add('hidden');
        }

        function updateChallengeUnitDisplay() {
            const selectedId = challengeHabitSelect.value;
            const duration = parseInt(challengeDurationSelect.value);
            const habit = habitDefinitions.find(h => h.id === selectedId);
            if (!habit) return;

            let unitText = 'times (count)';
            if (habit.type.includes('number')) {
                 unitText = `${habit.unit} total`;
                 challengeTargetInput.value = (habit.target * duration).toFixed(habit.unit === 'hrs' ? 1 : 0);
                 challengeTargetInput.step = habit.unit === 'hrs' ? '0.1' : '1';
            } else {
                 unitText = 'days completed';
                 challengeTargetInput.value = 7 * duration; // Default to 7 per week
                 challengeTargetInput.step = '1';
            }
            
            challengeUnitDisplay.textContent = unitText;
        }
        
        /**
         * Finalizes challenge creation and saves it to Firestore/Session Storage.
         */
        async function createChallengeFinal() {
            const type = challengeModal.dataset.type;
            const habitId = challengeHabitSelect.value;
            const target = parseFloat(challengeTargetInput.value); // Use parseFloat for targets
            const durationWeeks = parseInt(challengeDurationSelect.value);
            
            if (isNaN(target) || target <= 0) {
                modalErrorMessage.textContent = "Please enter a valid target goal.";
                return;
            }

            const challengeId = generateRandomId();
            const startDate = getDateKey(today);
            const endDate = new Date(today);
            endDate.setDate(endDate.getDate() + (durationWeeks * 7) - 1);
            
            const habit = habitDefinitions.find(h => h.id === habitId);
            const habitName = habit.name.replace(/\s\(.*\)/g, '').trim();
            const generatedChallengeName = `${type === 'group' ? 'Group' : 'Solo'} Challenge: ${habitName}`;

            const challengeData = {
                id: challengeId,
                type: type, 
                groupId: type === 'group' ? groupId : null,
                createdBy: userId || 'default', // Use 'default' placeholder when offline
                name: generatedChallengeName,
                habitId: habitId,
                target: target,
                unit: habit.unit || 'days',
                durationWeeks: durationWeeks,
                startDate: startDate,
                endDate: getDateKey(endDate),
                
                participants: { [userId || 'default']: { progress: 0, lastUpdated: new Date().toISOString() } } // Ensure current user is in participants
            };

            // --- OFFLINE MODE: Bypass database save, use session storage ---
            if (!window.auth) {
                 activeChallenge = challengeData;
                 renderActiveChallengeUI(); // Render immediately to display challenge
                 
                 // Manually populate other members for demo purposes
                 if (type === 'group') {
                      activeChallenge.participants = {
                           [userId || 'default']: { progress: 0, lastUpdated: new Date().toISOString() },
                           'MOCK001': { progress: 0, lastUpdated: new Date().toISOString() },
                           'MOCK002': { progress: 0, lastUpdated: new Date().toISOString() },
                      };
                 }
                 
                 sessionStorage.setItem('activeChallenge', JSON.stringify(activeChallenge));
                 modalErrorMessage.textContent = `Challenge "${generatedChallengeName}" started in Offline Mode!`;
                 setTimeout(closeChallengeModal, 1000);
                 return;
            }
            // --- END OFFLINE MODE ---

            try {
                // ONLINE MODE
                if (type === 'group') {
                     Object.keys(groupMembers).forEach(memberId => {
                         challengeData.participants[memberId] = { progress: 0, lastUpdated: new Date().toISOString() };
                     });
                }
                
                await firestoreFunctions.setDoc(getChallengePath(challengeId), challengeData);
                await firestoreFunctions.setDoc(getUserGroupMetadataPath(), { activeChallengeId: challengeId }, { merge: true });

                modalErrorMessage.textContent = `Challenge "${generatedChallengeName}" started!`;
                setTimeout(closeChallengeModal, 1000);

            } catch (e) {
                console.error("Error starting challenge:", e);
                modalErrorMessage.textContent = "Failed to start challenge. Check console.";
            }
        }


        // --- 6. Persistence & Core Functions ---

        async function saveHabitDefinitions() {
            if (!userId || !firestoreFunctions) return;
            const docRef = getHabitDefinitionsPath();
            await firestoreFunctions.setDoc(docRef, { definitions: habitDefinitions });
        }

        async function saveDailyEntry(dateKey, data) {
            if (!userId || !firestoreFunctions) return;
            const docRef = getUserDataPath(dateKey);
            await firestoreFunctions.setDoc(docRef, data, { merge: true });
            
            // Trigger challenge progress update after every save
            if (activeChallenge && dateKey >= activeChallenge.startDate && dateKey <= activeChallenge.endDate) {
                 updateChallengeProgress(activeChallenge);
            }
        }
        
        function setupHabitDefinitionsListener() {
            if (!userId || !firestoreFunctions) return;
            const docRef = getHabitDefinitionsPath();

            firestoreFunctions.onSnapshot(docRef, (docSnap) => {
                if (docSnap.exists() && docSnap.data().definitions) {
                    habitDefinitions = docSnap.data().definitions;
                } else if (habitDefinitions.length === 0) {
                    // This fallback logic now runs only if Firebase is connected but no data exists.
                    habitDefinitions = getDefaultHabitDefinitions(); 
                    saveHabitDefinitions(); 
                }
                
                renderHabitSetupUI();
                renderHabitTrackingUI();
                updateAllMetrics(); 
            }, (error) => {
                console.error("Error listening to habit definitions:", error);
            });
        }
        
        function setupDailyEntriesListener() {
            if (!userId || !firestoreFunctions) return;
            const collectionRef = firestoreFunctions.collection(db, 'artifacts', appId, 'users', userId, 'dailyEntries');

            firestoreFunctions.onSnapshot(collectionRef, (snapshot) => {
                habitData = {};
                snapshot.forEach(doc => {
                    habitData[doc.id] = doc.data();
                });
                
                loadHabitsForSelectedDate(); 
                updateAllMetrics();
                
                loadingOverlay.style.display = 'none';
            }, (error) => {
                console.error("Error listening to daily entries:", error);
                loadingOverlay.style.display = 'none';
            });
        }

        // --- NEW: Default Habit Definitions Function ---
        function getDefaultHabitDefinitions() {
             return [
                { id: 'h1', name: 'Exercise', type: 'checkbox', target: 1, unit: null, color: getHabitColor(0) },
                { id: 'h2', name: 'Walk', type: 'checkbox', target: 1, unit: null, color: getHabitColor(1) },
                { id: 'h3', name: 'Hydrate', type: 'number-cup', target: 13, unit: 'cups', color: getHabitColor(2) },
                { id: 'h4', name: 'Sleep', type: 'number-hr', target: 8, unit: 'hrs', color: getHabitColor(3) },
                { id: 'h5', name: 'Learn', type: 'number-hr', target: 3, unit: 'hrs', color: getHabitColor(4) },
                { id: 'h6', name: 'Phone Time', type: 'number-hr', target: 3, unit: 'hrs', targetType: 'max', color: getHabitColor(5) },
                { id: 'h7', name: 'Rise Early', type: 'checkbox', target: 1, unit: null, color: getHabitColor(6) },
            ];
        }
        
        // --- 7. UI Rendering Functions (Hoisted) ---
        
        function renderHabitSetupUI() {
            habitSetupList.innerHTML = '';
            habitDefinitions.forEach((habit, index) => {
                const item = document.createElement('div');
                item.className = 'flex items-center justify-between p-2 bg-neutral-800 rounded-md';
                item.innerHTML = `
                    <span class="text-sm text-neutral-300 flex-grow">${habit.name} (${habit.type.split('-')[0]})</span>
                    <button data-id="${habit.id}" class="remove-habit-btn text-red-500 hover:text-red-400 p-1 rounded-full">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                `;
                habitSetupList.appendChild(item);
            });
        }

        function renderHabitTrackingUI() {
            const dateKey = getDateKey(selectedDate);
            const data = habitData[dateKey] || {};
            
            habitsList.innerHTML = '';

            habitDefinitions.forEach(habit => {
                let inputHtml = '';
                const state = data[habit.id] !== undefined ? data[habit.id] : 0;
                
                if (habit.type === 'checkbox') {
                    const check = state === 1 ? '' : state === 2 ? '' : '';
                    const clickableClass = getDateKey(selectedDate) <= getDateKey(today) ? 'clickable' : '';
                    inputHtml = `
                        <div class="habit-checkbox ${clickableClass}" data-state="${state}" data-id="${habit.id}" data-type="${habit.type}" style="border-color:${habit.color}; background-color: ${state === 0 ? '#404040' : habit.color};">
                            ${check}
                        </div>
                    `;
                } else if (habit.type.startsWith('number')) {
                    const value = data[habit.id] || '';
                    const step = habit.unit === 'hrs' ? '0.1' : '1';
                    const targetText = habit.targetType === 'max' ? `(Max ${habit.target} ${habit.unit})` : `(Target ${habit.target} ${habit.unit})`;
                    
                    inputHtml = `
                        <input id="${habit.id}-input" type="number" step="${step}" min="0" 
                               class="hour-input styled-input text-center" 
                               placeholder="0${step === '0.1' ? '.0' : ''}" 
                               value="${value}" data-id="${habit.id}" data-type="${habit.type}">
                    `;
                    // Adjust habit name display for number types
                    const originalName = habit.name.replace(/\s\(.*\)/g, '').trim();
                    habit.name = `${originalName} ${targetText}`;
                }
                
                const item = document.createElement('div');
                item.className = `habit-item ${habit.type === 'checkbox' && getDateKey(selectedDate) <= getDateKey(today) ? 'clickable' : ''}`;
                item.innerHTML = `
                    <span class="font-medium text-neutral-300">${habit.name}</span>
                    ${inputHtml}
                `;
                habitsList.appendChild(item);
            });
            
            // Always append the Remark input field
            const remarkValue = data['remark'] || '';
            habitsList.innerHTML += `
                <div class="mt-4">
                    <input id="remark-input" type="text" class="styled-input remark-input" 
                           placeholder="How was today?" value="${remarkValue}" data-id="remark">
                </div>
            `;
        }

        // --- 8. Core Logic & Metric Functions (Hoisted) ---
        
        function calculateDailyScore(dateKey) {
            const data = habitData[dateKey] || {};
            let score = 0;
            let activityLogged = false; 
            let maxPoints = 0;
            
            habitDefinitions.forEach(habit => {
                maxPoints++;
                const value = data[habit.id];
                
                if (habit.type === 'checkbox') {
                    if (value === 1) score++;
                    if (value !== undefined && value !== 0) activityLogged = true; 
                } else if (habit.type.startsWith('number')) {
                    const numValue = parseFloat(value) || 0;
                    
                    if (habit.targetType === 'max') {
                        if (numValue > 0 && numValue <= habit.target) score++;
                    } else {
                        if (numValue >= habit.target) score++;
                    }
                    if (value !== undefined && value !== '') activityLogged = true;
                }
            });

            maxPoints++;
            if (activityLogged || (data['remark'] && data['remark'].trim() !== '')) {
                score++; 
            }

            return Math.min(score, 10); 
        }

        function calculateStreak() {
            let streak = 0;
            let currentDate = new Date(today);
            currentDate.setHours(0, 0, 0, 0); 
            const todayKey = getDateKey(today);

            if (habitData[todayKey] && calculateDailyScore(todayKey) === 10) {
                streak = 1;
                currentDate.setDate(currentDate.getDate() - 1);
            } else {
                currentDate.setDate(currentDate.getDate() - 1);
            }

            while (currentDate.getTime() < today.getTime()) {
                const dateKey = getDateKey(currentDate);
                
                if (habitData[dateKey] && calculateDailyScore(dateKey) === 10) {
                    streak++;
                } else {
                    break; 
                }
                
                currentDate.setDate(currentDate.getDate() - 1);
            }

            streakValue.textContent = streak;
        }

        function calculateMonthlyScore() {
            let monthlyTotal = 0;
            const monthStr = (currentMonth + 1).toString().padStart(2, '0');
            for (const dateKey in habitData) {
                if (dateKey.startsWith(`${currentYear}-${monthStr}`)) {
                    monthlyTotal += calculateDailyScore(dateKey);
                }
            }
            return monthlyTotal;
        }

        function updateAllMetrics() {
            buildCalendar(currentMonth, currentYear); 
            tooltipMonthlyScore.textContent = calculateMonthlyScore();
            updateMonthlyStats();
            calculateStreak();
        }

        function updateMonthlyStats() {
            let completed = 0;
            let failed = 0;
            let skipped = 0;
            const monthStr = (currentMonth + 1).toString().padStart(2, '0');
            const checkboxHabitIds = habitDefinitions.filter(h => h.type === 'checkbox').map(h => h.id);

            for (const dateKey in habitData) {
                if (dateKey.startsWith(`${currentYear}-${monthStr}`)) {
                    const data = habitData[dateKey];
                    checkboxHabitIds.forEach(habitId => {
                        const state = data[habitId] !== undefined ? data[habitId] : 0;
                        if (state === 1) {
                            completed++;
                        } else if (state === 2) {
                            failed++;
                        } else {
                            if (new Date(dateKey) <= today) {
                                skipped++;
                            }
                        }
                    });
                }
            }

            statsCompleted.textContent = completed;
            statsFailed.textContent = failed;
            statsSkipped.textContent = skipped;
        }

        function updateAverages() {
            avgBarsContainer.innerHTML = '';
            const dateKey = getDateKey(selectedDate);
            const data = habitData[dateKey] || {};

            habitDefinitions.forEach((habit, index) => {
                let percent = 0;
                let barColor = habit.color;
                const value = data[habit.id];
                
                if (habit.type === 'checkbox') {
                    percent = (value === 1) ? 100 : 0;
                } else if (habit.type.startsWith('number')) {
                    const numValue = parseFloat(value) || 0;
                    if (habit.targetType === 'max') {
                         percent = Math.max(0, Math.min(100, (1 - (numValue / habit.target)) * 100));
                         barColor = (numValue > habit.target) ? '#dc2626' : habit.color;
                    } else {
                        percent = Math.min(100, (numValue / habit.target) * 100);
                    }
                }

                const originalName = habit.name.replace(/\s\(.*\)/g, '').trim();
                
                avgBarsContainer.innerHTML += `
                    <div>
                        <p class="text-sm font-medium text-neutral-300">${originalName}</p>
                        <div class="stat-bar-bg mt-1">
                            <div class="stat-bar-fill" style="width: ${percent}%; background-color: ${barColor};"></div> 
                        </div>
                    </div>
                `;
            });
        }

        async function saveAndRefresh(element) {
            // ONLY attempt to save if the database connection is active (window.auth exists)
            if (!userId || getDateKey(selectedDate) > getDateKey(today) || !window.auth) return; 

            const dateKey = getDateKey(selectedDate);
            const habitId = element.dataset.id;
            let updatePayload = {};
            
            if (element.dataset.type === 'checkbox') {
                updatePayload = { [habitId]: parseInt(element.dataset.state) };
            } else if (element.id === 'remark-input') {
                updatePayload = { remark: element.value };
            } else if (element.dataset.type && element.dataset.type.startsWith('number')) {
                updatePayload = { [habitId]: element.value };
            } else {
                return; 
            }

            habitData[dateKey] = habitData[dateKey] || {};
            Object.assign(habitData[dateKey], updatePayload);

            await saveDailyEntry(dateKey, updatePayload);
            
            const dailyScore = calculateDailyScore(dateKey);
            tooltipTodayScore.textContent = `${dailyScore} / 10`;
            
            updateAverages(); 
            updateAllMetrics();
        }

        function loadHabitsForSelectedDate() {
            // --- OFFLINE FIX: Ensure habitDefinitions are set before rendering ---
            if (habitDefinitions.length === 0) {
                 habitDefinitions = getDefaultHabitDefinitions();
            }
            // --- END OFFLINE FIX ---

            renderHabitTrackingUI();
            
            const dateKey = getDateKey(selectedDate);
            const dailyScore = calculateDailyScore(dateKey);
            tooltipTodayScore.textContent = `${dailyScore} / 10`;
            
            const day = selectedDate.getDate();
            const month = monthNames[selectedDate.getMonth()];
            let title = `${month} ${day} Habits`;
            if (getDateKey(selectedDate) === getDateKey(today)) {
                title = "Today's Habits";
            }
            habitsTitle.textContent = title;

            updateAverages(); 
        }

        function buildCalendar(month, year) {
            calendarGrid.innerHTML = ''; 
            monthYearTitle.textContent = `${monthNames[month]} ${year}`;
            
            let firstDayOfMonth = new Date(year, month, 1);
            let firstDayOfWeek = firstDayOfMonth.getDay(); 
            let startOffset = (firstDayOfWeek === 0) ? 6 : firstDayOfWeek - 1; 
            
            let daysInMonth = new Date(year, month + 1, 0).getDate();
            let daysInPrevMonth = new Date(year, month, 0).getDate();
            
            let dayCounter = 1;
            let nextMonthDayCounter = 1;
            
            for (let i = 0; i < 42; i++) {
                const contentElement = document.createElement('div'); 
                contentElement.classList.add('calendar-content'); 
                
                const cellElement = document.createElement('div'); 
                cellElement.classList.add('calendar-cell'); 
                
                if (i < startOffset) {
                    cellElement.classList.add('other-month');
                    contentElement.textContent = daysInPrevMonth - startOffset + i + 1;
                } else if (dayCounter <= daysInMonth) {
                    cellElement.classList.add('current-month');
                    contentElement.textContent = dayCounter;
                    cellElement.dataset.day = dayCounter; 
                    
                    const thisDate = new Date(year, month, dayCounter);
                    
                    if (getDateKey(thisDate) === getDateKey(today)) {
                        cellElement.classList.add('today'); 
                    }
                    
                    if (getDateKey(thisDate) === getDateKey(selectedDate)) {
                        cellElement.classList.add('selected'); 
                    }
                    
                    dayCounter++;
                } else {
                    cellElement.classList.add('other-month');
                    contentElement.textContent = nextMonthDayCounter;
                    nextMonthDayCounter++;
                }
                cellElement.appendChild(contentElement); 
                calendarGrid.appendChild(cellElement); 
            }
            tooltipMonthlyScore.textContent = calculateMonthlyScore();
            updateMonthlyStats(); 
        }

        // --- 9. Event Listeners ---
        
        document.addEventListener('DOMContentLoaded', () => {

            db = window.db;
            auth = window.auth;
            appId = window.appId;
            initialAuthToken = window.initialAuthToken;
            firestoreFunctions = window.firestore;

            // Group Button Handlers
            createGroupBtn.addEventListener('click', () => {
                if (groupId) {
                    leaveGroup();
                } else {
                    createGroup();
                }
            });
            joinGroupBtn.addEventListener('click', joinGroup);

            // Challenge Button Handlers (NEW)
            soloChallengeBtn.addEventListener('click', () => openChallengeModal('solo'));
            groupChallengeBtn.addEventListener('click', () => openChallengeModal('group'));
            challengeCompleteBtn.addEventListener('click', endChallengeLocally);

            // Modal Handlers (NEW)
            challengeHabitSelect.addEventListener('change', updateChallengeUnitDisplay);
            challengeDurationSelect.addEventListener('change', updateChallengeUnitDisplay);
            modalCancelBtn.addEventListener('click', closeChallengeModal);
            modalStartBtn.addEventListener('click', createChallengeFinal);
            
            // Habit Setup Listeners
            addHabitBtn.addEventListener('click', () => {
                // If offline, just push to local array
                if (!window.auth) {
                    const newHabit = {
                        id: 'h' + (Date.now()).toString().slice(-6),
                        name: newHabitNameInput.value.trim(),
                        type: newHabitTypeSelect.value,
                        target: 1, unit: null, targetType: 'min',
                        color: getHabitColor(habitDefinitions.length)
                    };
                    habitDefinitions.push(newHabit);
                    renderHabitSetupUI();
                    renderHabitTrackingUI();
                    newHabitNameInput.value = '';
                    return;
                }

                const name = newHabitNameInput.value.trim();
                const type = newHabitTypeSelect.value;
                if (!name) return;

                const newId = 'h' + (Date.now()).toString().slice(-6);
                let target = 1;
                let unit = null;
                let targetType = 'min';

                if (type === 'number-hr') {
                    target = name.toLowerCase().includes('phone') ? 3 : 8;
                    unit = 'hrs';
                    if (name.toLowerCase().includes('phone')) targetType = 'max';
                } else if (type === 'number-cup') {
                    target = 13;
                    unit = 'cups';
                }

                const newHabit = {
                    id: newId,
                    name: name,
                    type: type,
                    target: target,
                    unit: unit,
                    targetType: targetType,
                    color: getHabitColor(habitDefinitions.length)
                };

                habitDefinitions.push(newHabit);
                saveHabitDefinitions();
                newHabitNameInput.value = '';
            });

            habitSetupList.addEventListener('click', async (event) => {
                const removeBtn = event.target.closest('.remove-habit-btn');
                if (removeBtn) {
                    const habitIdToRemove = removeBtn.dataset.id;
                    
                    habitDefinitions = habitDefinitions.filter(h => h.id !== habitIdToRemove);
                    
                    if (window.auth) {
                        await saveHabitDefinitions();
                    } else {
                        renderHabitSetupUI();
                        renderHabitTrackingUI();
                    }
                }
            });

            // Daily Habits Tracking Listeners
            habitsList.addEventListener('click', (event) => {
                const checkbox = event.target.closest('.habit-checkbox');
                if (!checkbox) return; 
                if (getDateKey(selectedDate) > getDateKey(today)) return;

                let currentState = parseInt(checkbox.dataset.state || '0');
                currentState = (currentState + 1) % 3; 
                checkbox.dataset.state = currentState;
                
                checkbox.textContent = currentState === 1 ? '' : currentState === 2 ? '' : '';
                checkbox.style.backgroundColor = currentState === 0 ? '#404040' : habitDefinitions.find(h => h.id === checkbox.dataset.id)?.color || '#f59e0b';
                
                saveAndRefresh(checkbox); 
            });

            habitsList.addEventListener('input', (event) => {
                 const input = event.target.closest('input');
                 if (input && (input.dataset.type || input.id === 'remark-input')) {
                    saveAndRefresh(input);
                 }
            });

            // Calendar and Navigation Listeners
            document.getElementById('prev-month-btn').addEventListener('click', () => {
                currentMonth--;
                if (currentMonth < 0) {
                    currentMonth = 11;
                    currentYear--;
                }
                selectedDate = new Date(currentYear, currentMonth, 1); 
                buildCalendar(currentMonth, currentYear);
                loadHabitsForSelectedDate(); 
            });

            document.getElementById('next-month-btn').addEventListener('click', () => {
                currentMonth++;
                if (currentMonth > 11) {
                    currentMonth = 0;
                    currentYear++;
                }
                selectedDate = new Date(currentYear, currentMonth, 1); 
                buildCalendar(currentMonth, currentYear);
                loadHabitsForSelectedDate(); 
            });

            calendarGrid.addEventListener('click', (event) => {
                const cellElement = event.target.closest('.current-month'); 
                if (!cellElement) return; 
                
                const day = parseInt(cellElement.dataset.day); 
                if (day !== selectedDate.getDate() || currentMonth !== selectedDate.getMonth() || currentYear !== selectedDate.getFullYear()) {
                    selectedDate = new Date(currentYear, currentMonth, day);
                    buildCalendar(currentMonth, currentYear); 
                    loadHabitsForSelectedDate(); 
                }
            });


            // --- 10. Initialization ---
            
            async function initializeApp() {
                loadingOverlay.style.display = 'flex';
                
                // --- OFFLINE MODE: Load default habits immediately ---
                if (!window.auth) {
                    userIdSpan.textContent = 'ERROR: No Database Connection (Offline Mode)';
                    userId = 'default'; // Set a mock ID for challenge tracking
                    
                    // Check session storage for existing offline challenge
                    const storedChallenge = sessionStorage.getItem('activeChallenge');
                    if (storedChallenge) {
                         try {
                              activeChallenge = JSON.parse(storedChallenge);
                         } catch(e) {
                              sessionStorage.removeItem('activeChallenge'); // Clear bad storage
                         }
                    }

                    habitDefinitions = getDefaultHabitDefinitions(); // Load the default set
                    loadingOverlay.style.display = 'none';
                    buildCalendar(currentMonth, currentYear);
                    loadHabitsForSelectedDate();
                    renderActiveChallengeUI(); // Render the challenge if loaded from storage
                    return;
                }

                try {
                    if (initialAuthToken) {
                        await firestoreFunctions.signInWithCustomToken(auth, initialAuthToken);
                    } else {
                        await firestoreFunctions.signInAnonymously(auth);
                    }
                } catch (error) {
                    console.error("Firebase Auth failed during sign-in attempt:", error);
                }

                firestoreFunctions.onAuthStateChanged(auth, (user) => {
                    loadingOverlay.style.display = 'none';
                    if (user) {
                        userId = user.uid;
                        userIdSpan.textContent = userId;
                        isAuthReady = true;

                        setupGroupMetadataListener(); 
                        setupHabitDefinitionsListener();
                        setupDailyEntriesListener(); 

                    } else {
                        userIdSpan.textContent = 'Auth Failed / Signed Out. Data will not save.';
                        buildCalendar(currentMonth, currentYear); 
                        loadHabitsForSelectedDate(); 
                    }
                });
                
                document.getElementById('main-title').textContent = `${monthNames[currentMonth]} Dashboard`;
            }
            
            initializeApp();
        });
    </script>
</body>
</html>
